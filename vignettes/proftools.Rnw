%%\VignetteIndexEntry{Using proftools}
\documentclass[nojss]{jss}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% almost as usual
\author{Luke Tierney\\University of Iowa \And 
        Riad Jarjour\\University of Iowa}
\title{Examining \proglang{R} Profiling Data: The \pkg{proftools} Package}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Luke Tierney, Riad Jarjour} %% comma-separated
\Plaintitle{Examining R Profiling Data:
  The proftools Package} %% without formatting
%$ \Shorttitle{\pkg{foo}: A Capitalized Title} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{
  This note introduces the \pkg{proftools} package for examining data
  collected by \proglang{R}'s sampling profiler.  \pkg{proftools}
  includes facilities for summarizing, filtering and visualizing
  profiling data. Use of the package is illustrated with a small
  running example.
}
\Keywords{\pkg{proftools}, profiling, \proglang{R}, \code{Rprof}}
\Plainkeywords{proftools, profiling, R, Rprof} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{50}
%% \Issue{9}
%% \Month{June}
%% \Year{2012}
%% \Submitdate{2012-06-04}
%% \Acceptdate{2012-06-04}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Luke Tierney\\
  Department of Statistics and Actuarial Science\\
  Faculty of Statistics\\
  University of Iowa\\
  Iowa City, USA\\
  E-mail: \email{luke-tierney@uiowa.edu}\\
  URL: \url{http://homepage.stat.uiowa.edu/~luke/}
  
  Riad Jarjour\\
  Department of Statistics and Actuarial Science\\
  Faculty of Statistics\\
  University of Iowa\\
  Iowa City, USA\\
  E-mail: \email{riad-jarjour@uiowa.edu}
}
%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/512/507-7103
%% Fax: +43/512/507-2851

%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{document}

%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and <<>>=} commands.

\section{Introduction}
<<echo=false,results=hide>>=
library("proftools")
options(keep.source = TRUE)
@ %%
Profiling is a program analysis method for determining where a program
run spends most of its execution time, and can be very helpful in
guiding programmer effort for improving program performance.
\proglang{R} includes a sampling based profiling mechanism that
records information about calls on the stack at specified time
intervals.  If available, information about the specific source code
lines active at the sampling point is recorded as well. Information
about time spent in the garbage collector can also be collected. The
collected profiling data is written to a file, by default the file
\code{Rprof.out} in the current working directory.  The function
\code{summaryRprof} provides a simple interface for examining this
data. The
\href{https://github.com/ltierney/Rpkg-proftools}{\pkg{proftools}}
package provides a much more extensive set of tools for summarizing,
visualizing, and filtering this data.

\section{Collecting Profile Data}
The \pkg{proftools} package includes an example script \code{bootlm.R}
in the \code{samples} directory that runs several examples from
the \pkg{boot} package and fits a simple linear model. The file
path can be obtained as
<<>>=
srcfile <- system.file("samples", "bootlmEx.R", package = "proftools")
@  %%

The traditional way to collect profiling data in R is to call
\code{Rprof} to start profiling, run the code to be profiled, and then
call \code{Rprof} again to end profiling. For example, to profile the
code in \code{bootlm.R}, and collect both source line and GC
information, you could use
<<eval = FALSE>>=
profout <- tempfile()
Rprof(file = profout, gc.profiling = TRUE, line.profiling = TRUE)
source(srcfile)
Rprof(NULL)
pd <- readProfileData(profout)
unlink(profout)
@ %%
The \pkg{proftools} package provides the alternative
<<>>=
pd <- profileExpr(source(srcfile))
@ %%
\code{profileExpr} by default enables GC and source information to be
collected. It also trims off stack information leading up to the
\code{profileExpr} call.

\section{Summary Functions}
The most basic summary function is \code{funSummary} for summarizing
profile results at the function level. It produces information similar
to the result returned by R's \code{summaryRprof} but in a more usable
form:
<<>>=
head(funSummary(pd), 10)
@ %%
Data can also be summarized by call:
<<>>=
head(callSummary(pd), 10)
@ %%

When source information is available in the profile data the
\code{srcSummary} function can be used to summarize at the source line
level; only lines appearing in the sample are included:
<<>>=
srcSummary(pd)
@ %%
The function \code{annotateSource} can show the full files with
profiling annotations.

A useful way to examine profile data is to look for hot execution
paths.  This approach sorts functions called at top level by the total
amount of time spent in their top level calls; within each top level
call to a function \code{f} the functions called by \code{f} are
sorted by the amount of time spent in them within the top level call
to \code{f}; and the process continues for higher level calls. The
function \code{hotPaths} produces a hot path summary; the
\code{maxdepth} argument determines how far up the call stack the
paths are followed:
<<>>=
hotPaths(pd, maxdepth = 6)
@ %%

%% Other summaries are \code{pathSummary} and \code{srcSummary}.
%% **** filtering

\section{Filtering Profile Data}
The hot path summary shows information associated with the source
command itself that is not directly relevant to our analysis. The
\code{filterProfileData} function can be uses to select or omit
certain functions, drop functions with small self or total times,
narrow to a particular time interval, among others.  For example, by
selecting only stack traces that include calls to \code{withVisible}
and then trimming off the leading four calls we can focus just on the
work done in the sourced file:
<<>>=
filteredPD <- filterProfileData(pd, select = "withVisible", skip = 4)
@ %%
The hot path summary for this reduced profile is
<<>>=
hotPaths(filteredPD, maxdepth = 3) 
@ %%

We can use the \code{focus} filter to further narrow our examination
to stack frames containing calls to \code{glm} and also remove all
calls preceding the first \code{glm} call from the selected stack
frames:
<<>>=
glmPD <- filterProfileData(filteredPD, focus = "glm")
hotPaths(glmPD, maxdepth = 3)
@ %%


\section{Visualizing Profile Data}
Call graphs annotated with profile information are a very popular way
to view profiling results.  \code{plotProfileCallGraph} uses the
\pkg{graph} and \pkg{Rgraphviz} packages from Bioconductor to render
an annotated call graph. The default style for the graph is based on
the style used in \href{https://github.com/gperftools}{Google's
  profiling library} but can be customized in a number of ways.  A
call graph for the full profile data is produced by
<<fullCallGraphCmd>>=
plotProfileCallGraph(pd)
@ 
and is shown in Figure \ref{fullCallGraphFig}
\begin{figure}
  \centering
<<fig=true,echo=false>>=
<<fullCallGraphCmd>>
@ %%
\caption{Full call graph of \code{pd}.}
\label{fullCallGraphFig}
\end{figure}

We can obtain a more readable graph by fitering. For example, to
examine the \code{boot} call and its callees we can use
<<bootCallGraphCmd>>=
plotProfileCallGraph(filterProfileData(pd, focus = "boot",
                                       total.pct = 5,
                                       maxdepth = 10))
@ 
\begin{figure}
  \centering
<<fig=true,echo=false>>=
<<bootCallGraphCmd>>
@ %%
\caption{Call graph for \code{boot} call.}
\label{bootCallGraphFig}
\end{figure}
The result is shown in Figure \ref{bootCallGraphFig}.

A printed version of the call graph, similar to the call graph
produced by \code{gprof} \citep{Graham:1982:GCG:800230.806987}, can be
obtained with \code{printProfileCallGraph}.  For the subgraph of the
\code{glm.fit} calls, for example,
<<printProfileCallGraph, eval=false>>=
printProfileCallGraph(filterProfileData(pd, focus = "glm.fit"))
@ %%
produces the printed representation shown in Figure \ref{printGraphFig}.
\begin{figure}
<<echo=false>>=
<<printProfileCallGraph>>
@ %%
\caption{Printed call graph.}
\label{printGraphFig}
\end{figure}

Another visualization sometimes used is a
\href{http://www.brendangregg.com/flamegraphs.html}{flame graph}.  By
default the \code{flameGraph} function orders functions within call
levels by execution time, which produces a visual representation of
the hot path summary;
<<flameGraphCmd>>=
flameGraph(pd)
@ %%
\begin{figure}
  \centering
<<fig=true,echo=false>>=
<<flameGraphCmd>>
@ %%
\caption{Flame graph visualizing hot paths for the full profile data.}
\label{flameGraphFig}
\end{figure}
the result is shown in Figure \ref{flameGraphFig}.  A flame graph of
the filtered data is produced by
<<filteredFlameGraphCmd>>=
flameGraph(filteredPD)
@ %%
\begin{figure}
  \centering
<<fig=true,echo=false>>=
<<filteredFlameGraphCmd>>
@ %%
\caption{Flame graph of the filtered profile data.}
\label{filteredFlameGraphFig}
\end{figure}
and shown in Figure \ref{filteredFlameGraphFig}
%% Furthermore, an svg file of the graph can be outputted by using the
%% svg argument:
%% <<eval=FALSE>>=
%% flameGraph(pd, svg = "graph.svg", order = "hot")
%% @ 

Specifying \code{order = "time"} shows the calls in the order in which
they occurred:
<<timeGraphCmd>>=
flameGraph(pd, order = "time")
@ %%
\begin{figure}
  \centering
<<fig=true,echo=false>>=
<<timeGraphCmd>>
@ %%
\caption{Time graph of the full profile data.}
\label{timeGraphFig}
\end{figure}
Figure \ref{timeGraphFig} shows the \code{boot} calls preceding the
data generation for the \code{lm} call and the \code{lm} call itself.

Flame graphs can also order functions within a level alphabetically.

A third visualization that is sometimes used is a callee tree map,
produced by
<<calleeTreeCmd>>=
calleeTreeMap(pd)
@ %%
\begin{figure}
  \centering
<<fig=true,echo=false>>=
<<calleeTreeCmd>>
@ %%
\caption{Call tree map of the full profile data.}
\label{calleeTreeMapFig}
\end{figure}
and shown in Figure \ref{calleeTreeMapFig}.

\section{Graphical User Interfaces}
The function \code{writeCallgrindFile} can be used to write the
profile data in \href{valgrind.org}{Valgrind's} \code{callgrind}
format for use with the
\href{http://kcachegrind.sourceforge.net/html/Home.html}{\code{kcachegrind}}
or \code{qcachegrind} graphical user interfaces available on Linux and
Mac OS X.

Graphical user interfaces within R will be made available in the
\href{https://github.com/ltierney/Rpkg-proftools-GUI}{\pkg{proftoolsGUI}}
package. The current development version provides two interfaces, one
based on \pkg{gWidgets2} and one on \pkg{shiny}.

\bibliography{proftools}
\end{document}
